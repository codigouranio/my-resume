---
# Application Deployment Playbook
# Deploys the full application stack

- name: Deploy My Resume Application
  hosts: all
  become: yes
  vars_files:
    - ../group_vars/all.yml
    - ../group_vars/all/vault-sandbox.yml

  tasks:
    - name: Clone/Update repository
      git:
        repo: "{{ repo_url }}"
        dest: "{{ app_root }}"
        version: "{{ repo_branch }}"
        force: yes
      become_user: "{{ ansible_user }}"

    # Prepare Node Services Environment

    - name: Create conda environment for node services
      shell: |
        /opt/miniconda3/bin/conda create -p {{ app_root }}/conda-env nodejs={{ nodejs_version }} -y
      args:
        creates: "{{ app_root }}/conda-env"
      become_user: "{{ ansible_user }}"

    - name: Configure API Service environment
      copy:
        dest: "{{ api_service_path }}/.env"
        content: |
          DATABASE_URL="postgresql://{{ db_user }}:{{ db_password }}@localhost:{{ postgres_port }}/{{ db_name }}?schema=public"
          JWT_SECRET="{{ jwt_secret }}"
          PORT={{ api_port }}
          NODE_ENV={{ node_env }}
          LLM_SERVICE_URL="http://localhost:{{ llm_port }}"
          CORS_ORIGINS="{{ cors_origins | join(',') }}"
          STRIPE_SECRET_KEY={{ stripe_secret_key | default('sk_test_placeholder_not_configured') }}
          STRIPE_WEBHOOK_SECRET={{ stripe_webhook_secret | default('whsec_placeholder_not_configured') }}
          STRIPE_PRICE_ID={{ stripe_price_id | default('price_placeholder_not_configured') }}
          AWS_REGION={{ aws_region | default('us-east-1') }}
          AWS_ACCESS_KEY_ID={{ aws_access_key_id | default('') }}
          AWS_SECRET_ACCESS_KEY={{ aws_secret_access_key | default('') }}
          SES_FROM_EMAIL={{ ses_from_email | default('noreply@resumecast.ai') }}
          FRONTEND_URL={{ frontend_url | default('https://resumecast.ai') }}
        owner: "{{ ansible_user }}"
        mode: "0600"

    - name: Install API Service dependencies
      shell: |
        source /opt/miniconda3/etc/profile.d/conda.sh
        conda activate {{ app_root }}/conda-env
        npm install
      args:
        chdir: "{{ api_service_path }}"
        executable: /bin/bash
      become_user: "{{ ansible_user }}"

    # - name: Stop deployment if a variable is set
    #   meta: end_play
    #   when: stop_deploy | default(false)      

    - name: Generate Prisma Client
      shell: |
        source /opt/miniconda3/etc/profile.d/conda.sh
        conda activate {{ app_root }}/conda-env
        export DATABASE_URL="postgresql://{{ db_user }}:{{ db_password }}@localhost:{{ postgres_port }}/{{ db_name }}?schema=public"
        npx prisma generate
      args:
        chdir: "{{ api_service_path }}"
        executable: /bin/bash
      become_user: "{{ ansible_user }}"

    - name: Check if migrations exist
      stat:
        path: "{{ api_service_path }}/prisma/migrations"
      register: migrations_dir

    - name: Apply Prisma migrations (production safe)
      shell: |
        source /opt/miniconda3/etc/profile.d/conda.sh
        conda activate {{ app_root }}/conda-env
        export DATABASE_URL="postgresql://{{ db_user }}:{{ db_password }}@localhost:{{ postgres_port }}/{{ db_name }}?schema=public"
        npx prisma migrate deploy
      args:
        chdir: "{{ api_service_path }}"
        executable: /bin/bash
      become_user: "{{ ansible_user }}"
      register: migration_result
      failed_when: false
      when: migrations_dir.stat.exists

    - name: Fallback to db push if no migrations
      shell: |
        source /opt/miniconda3/etc/profile.d/conda.sh
        conda activate {{ app_root }}/conda-env
        export DATABASE_URL="postgresql://{{ db_user }}:{{ db_password }}@localhost:{{ postgres_port }}/{{ db_name }}?schema=public"
        npx prisma db push --accept-data-loss
      args:
        chdir: "{{ api_service_path }}"
        executable: /bin/bash
      become_user: "{{ ansible_user }}"
      when: not migrations_dir.stat.exists or migration_result.rc != 0

    - name: Verify database tables
      postgresql_query:
        db: "{{ db_name }}"
        login_user: "{{ db_user }}"
        login_password: "{{ db_password }}"
        login_host: localhost
        query: |
          SELECT table_name 
          FROM information_schema.tables 
          WHERE table_schema = 'public'
          ORDER BY table_name;
      register: db_tables
      become_user: postgres

    - name: Display created tables
      debug:
        msg: "Database tables: {{ db_tables.query_result | map(attribute='table_name') | list }}"

    - name: Build API Service
      shell: |
        source /opt/miniconda3/etc/profile.d/conda.sh
        conda activate {{ app_root }}/conda-env
        npm run build
      args:
        chdir: "{{ api_service_path }}"
        executable: /bin/bash
      become_user: "{{ ansible_user }}"

    # Prepare LLM Service Environment

    - name: Ensure LLM service directory exists
      file:
        path: "{{ llm_service_path }}"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user | default(ansible_user) }}"
        mode: '0755'
      become: yes   # Needed if /opt/my-resume requires root to create/write

    - name: Create conda environment for LLM service (Python)
      command: /opt/miniconda3/bin/conda create -p {{ llm_service_path }}/conda-env python=3.10 pip -y --quiet
      args:
        creates: "{{ llm_service_path }}/conda-env/conda-meta/history"
      become_user: "{{ ansible_user }}"
      register: conda_create_llm
      changed_when: conda_create_llm.rc == 0

    - name: Install LLM service Python dependencies
      shell: |
        source /opt/miniconda3/etc/profile.d/conda.sh
        conda activate {{ llm_service_path }}/conda-env
        conda install -y -c conda-forge flask flask-cors requests python-dotenv psycopg2-binary
      args:
        executable: /bin/bash
      become_user: "{{ ansible_user }}"

    - name: Configure LLM Service environment
      copy:
        dest: "{{ llm_service_path }}/.env"
        content: |
          PORT={{ llm_port }}
          LLAMA_SERVER_URL={{ llama_server_url }}
          LLAMA_API_TYPE=ollama
          OLLAMA_MODEL={{ ollama_model }}
          RESUME_PATH=../../data/resume.md
          DATABASE_URL=postgresql://{{ db_user }}:{{ db_password }}@localhost:{{ postgres_port }}/{{ db_name }}
          ADMIN_TOKEN={{ llm_admin_token }}
          API_BASE_URL=http://localhost:{{ api_port }}/api
          RESUME_SLUG=jose-blanco-swe
        owner: "{{ ansible_user }}"
        mode: "0600"

    - name: Check if Ollama is installed
      command: which ollama
      register: ollama_check
      ignore_errors: yes
      changed_when: false

    - name: Pull main Ollama model for chat
      command: ollama pull {{ ollama_model }}
      become_user: "{{ ansible_user }}"
      when: ollama_check.rc == 0
      async: 300
      poll: 10

    - name: Pull nomic-embed-text model for embeddings
      command: ollama pull nomic-embed-text
      become_user: "{{ ansible_user }}"
      when: ollama_check.rc == 0
      async: 300
      poll: 10

    - name: Display Ollama models
      shell: ollama list
      register: ollama_models
      become_user: "{{ ansible_user }}"
      when: ollama_check.rc == 0
      changed_when: false

    - name: Show installed models
      debug:
        msg: "{{ ollama_models.stdout_lines }}"
      when: ollama_check.rc == 0

    # Prepare Frontend Environment

    - name: Ensure frontend directory exists
      file:
        path: "{{ frontend_path }}"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'
      become: yes      

    - name: Verify frontend conda env was created
      stat:
        path: "{{ app_root }}/conda-env/bin/node"
      register: frontend_node_check
      become_user: "{{ ansible_user }}"

    - name: Fail if frontend conda env missing node binary
      fail:
        msg: "Frontend conda env at {{ app_root }}/conda-env does not contain node binary - creation likely failed"
      when: not frontend_node_check.stat.exists

    - name: Install Frontend dependencies (clean reinstall to fix Rspack bindings)
      block:
        - name: Clean node_modules and lockfile (to force platform-specific bindings install)
          file:
            path: "{{ frontend_path }}/{{ item }}"
            state: absent
          loop:
            - node_modules
            - package-lock.json
          become_user: "{{ ansible_user }}"

        - name: Install frontend dependencies fresh
          command: /opt/miniconda3/bin/conda run -p {{ app_root }}/conda-env npm install
          args:
            chdir: "{{ frontend_path }}"
          become_user: "{{ ansible_user }}"
      become_user: "{{ ansible_user }}"

    - name: Build Frontend (using conda run - no activation needed)
      command: /opt/miniconda3/bin/conda run -p {{ app_root }}/conda-env npm run build
      args:
        chdir: "{{ frontend_path }}"
      become_user: "{{ ansible_user }}"
      register: frontend_build_result
      changed_when: frontend_build_result.rc == 0

    # Keep your existing verify/assert tasks - they are good
    - name: Verify Frontend build
      stat:
        path: "{{ frontend_path }}/dist/index.html"
      register: frontend_build
      become_user: "{{ ansible_user }}"

    - name: Assert Frontend build succeeded
      assert:
        that: frontend_build.stat.exists
        fail_msg: "Frontend build failed - dist/index.html not found"
        success_msg: "✅ Frontend built successfully"      

    # Finalize PM2 Setup and Start Services

    - name: Install PM2
      shell: |
        source /opt/miniconda3/etc/profile.d/conda.sh
        conda activate {{ app_root }}/conda-env
        npm config set prefix {{ app_root }}/conda-env
        npm install -g pm2
      args:
        creates: "{{ app_root }}/conda-env/bin/pm2"
        executable: /bin/bash
      become_user: "{{ ansible_user }}"    

    - name: Create PM2 ecosystem file
      template:
        src: ../templates/ecosystem.config.js.j2
        dest: "{{ app_root }}/ecosystem.config.js"
        owner: "{{ ansible_user }}"
        mode: "0644"

    - name: Check PM2 installation
      command: "{{ app_root }}/conda-env/bin/pm2 --version"
      register: pm2_version
      become_user: "{{ ansible_user }}"
      changed_when: false

    - name: Stop existing PM2 services
      shell: |
        source /opt/miniconda3/etc/profile.d/conda.sh
        conda activate {{ app_root }}/conda-env
        $(npm root -g)/pm2/bin/pm2 delete all || true
      args:
        executable: /bin/bash
      become_user: "{{ ansible_user }}"
      ignore_errors: yes

    - name: Start services with PM2
      shell: |
        source /opt/miniconda3/etc/profile.d/conda.sh
        conda activate {{ app_root }}/conda-env
        $(npm root -g)/pm2/bin/pm2 start ecosystem.config.js
      args:
        chdir: "{{ app_root }}"
        executable: /bin/bash
      become_user: "{{ ansible_user }}"

    - name: Save PM2 configuration
      shell: |
        source /opt/miniconda3/etc/profile.d/conda.sh
        conda activate {{ app_root }}/conda-env
        $(npm root -g)/pm2/bin/pm2 save --force
      args:
        executable: /bin/bash
      become_user: "{{ ansible_user }}"

    - name: Setup PM2 startup script
      shell: |
        source /opt/miniconda3/etc/profile.d/conda.sh
        conda activate {{ app_root }}/conda-env
        # $(npm root -g)/pm2/bin/pm2 startup systemd -u {{ ansible_user }} --hp /home/{{ ansible_user }}
      args:
        executable: /bin/bash
      register: pm2_startup
      become_user: "{{ ansible_user }}"

    - name: Execute PM2 startup command
      shell: "{{ pm2_startup.stdout_lines | select('match', '^sudo.*') | first }}"
      when: pm2_startup.stdout_lines | select('match', '^sudo.*') | list | length > 0

    - name: Wait for services to start
      wait_for:
        port: "{{ item }}"
        delay: 5
        timeout: 30
      loop:
        - "{{ api_port }}"
        - "{{ llm_port }}"

    - name: Check PM2 services status
      shell: |
        source /opt/miniconda3/etc/profile.d/conda.sh
        conda activate {{ app_root }}/conda-env
        $(npm root -g)/pm2/bin/pm2 list
      args:
        executable: /bin/bash
      become_user: "{{ ansible_user }}"
      register: pm2_status

    - name: Display PM2 status
      debug:
        msg: "{{ pm2_status.stdout_lines }}"

    - name: Test API health endpoint
      uri:
        url: "http://localhost:{{ api_port }}/api/health"
        method: GET
        status_code: [200, 404]
      register: api_health
      ignore_errors: yes

    - name: Display API health status
      debug:
        msg: "API Service: {{ 'HEALTHY' if api_health.status == 200 else 'STARTED (health endpoint may not exist)' }}"

    - name: Display completion message
      debug:
        msg:
          - "✅ Application deployment completed successfully!"
          - ""
          - "Services Status:"
          - "  API Service: Running on port {{ api_port }}"
          - "  LLM Service: Running on port {{ llm_port }}"
          - ""
          - "Next step: Run 04-nginx-setup.yml to configure web server"
